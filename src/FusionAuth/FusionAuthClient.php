<?php
namespace FusionAuth;

/*
 * Copyright (c) 2018-2019, FusionAuth, All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

/**
 * Client that connects to a FusionAuth server and provides access to the full set of FusionAuth APIs.
 * <p/>
 * When any method is called the return value is always a ClientResponse object. When an API call was successful, the
 * response will contain the response from the server. This might be empty or contain an success object or an error
 * object. If there was a validation error or any other type of error, this will return the Errors object in the
 * response. Additionally, if FusionAuth could not be contacted because it is down or experiencing a failure, the response
 * will contain an Exception, which could be an IOException.
 *
 * @author Brian Pontarelli
 */
class FusionAuthClient
{
  /**
   * @var string
   */
  private $apiKey;

  /**
   * @var string
   */
  private $baseURL;

  /**
   * @var string
   */
  private $tenantId;

  /**
   * @var int
   */
  public $connectTimeout = 2000;

  /**
   * @var int
   */
  public $readTimeout = 2000;

  public function __construct($apiKey, $baseURL)
  {
    include_once 'RESTClient.php';
    $this->apiKey = $apiKey;
    $this->baseURL = $baseURL;
  }

  public function withTenantId($tenantId) {
    $this->tenantId = $tenantId;
    return $this;
  }

  /**
   * Takes an action on a user. The user being actioned is called the "actionee" and the user taking the action is called the
   * "actioner". Both user ids are required. You pass the actionee's user id into the method and the actioner's is put into the
   * request object.
   *
   * @param string $actioneeUserId The actionee's user id.
   * @param array $request The action request that includes all of the information about the action being taken including
  *     the id of the action, any options and the duration (if applicable).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function actionUser($actioneeUserId, $request)
  {
    return $this->start()->uri("/api/user/action")
        ->urlSegment($actioneeUserId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Adds a user to an existing family. The family id must be specified.
   *
   * @param string $familyId The id of the family.
   * @param array $request The request object that contains all of the information used to determine which user to add to the family.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function addUserToFamily($familyId, $request)
  {
    return $this->start()->uri("/api/user/family")
        ->urlSegment($familyId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Cancels the user action.
   *
   * @param string $actionId The action id of the action to cancel.
   * @param array $request The action request that contains the information about the cancellation.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function cancelAction($actionId, $request)
  {
    return $this->start()->uri("/api/user/action")
        ->urlSegment($actionId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->delete()
        ->go();
  }

  /**
   * Changes a user's password using the change password Id. This usually occurs after an email has been sent to the user
   * and they clicked on a link to reset their password.
   *
   * @param string $changePasswordId The change password Id used to find the user. This value is generated by FusionAuth once the change password workflow has been initiated.
   * @param array $request The change password request that contains all of the information used to change the password.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function changePassword($changePasswordId, $request)
  {
    return $this->startAnonymous()->uri("/api/user/change-password")
        ->urlSegment($changePasswordId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Changes a user's password using their identity (login id and password). Using a loginId instead of the changePasswordId
   * bypasses the email verification and allows a password to be changed directly without first calling the #forgotPassword
   * method.
   *
   * @param array $request The change password request that contains all of the information used to change the password.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function changePasswordByIdentity($request)
  {
    return $this->start()->uri("/api/user/change-password")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Adds a comment to the user's account.
   *
   * @param array $request The request object that contains all of the information used to create the user comment.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function commentOnUser($request)
  {
    return $this->start()->uri("/api/user/comment")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
   *
   * @param string $applicationId (Optional) The Id to use for the application. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the application.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createApplication($applicationId, $request)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a new role for an application. You must specify the id of the application you are creating the role for.
   * You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
   *
   * @param string $applicationId The Id of the application to create the role on.
   * @param string $roleId (Optional) The Id of the role. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the application role.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createApplicationRole($applicationId, $roleId, $request)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlSegment("role")
        ->urlSegment($roleId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates an audit log with the message and user name (usually an email). Audit logs should be written anytime you
   * make changes to the FusionAuth database. When using the FusionAuth App web interface, any changes are automatically
   * written to the audit log. However, if you are accessing the API, you must write the audit logs yourself.
   *
   * @param array $request The request object that contains all of the information used to create the audit log entry.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createAuditLog($request)
  {
    return $this->start()->uri("/api/system/audit-log")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a user consent type. You can optionally specify an Id for the consent type, if not provided one will be generated.
   *
   * @param string $consentId (Optional) The Id for the consent. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the consent.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createConsent($consentId, $request)
  {
    return $this->start()->uri("/api/consent")
        ->urlSegment($consentId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
   *
   * @param string $emailTemplateId (Optional) The Id for the template. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the email template.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createEmailTemplate($emailTemplateId, $request)
  {
    return $this->start()->uri("/api/email/template")
        ->urlSegment($emailTemplateId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a family with the user id in the request as the owner and sole member of the family. You can optionally specify an id for the
   * family, if not provided one will be generated.
   *
   * @param string $familyId (Optional) The id for the family. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the family.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createFamily($familyId, $request)
  {
    return $this->start()->uri("/api/user/family")
        ->urlSegment($familyId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
   *
   * @param string $groupId (Optional) The Id for the group. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the group.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createGroup($groupId, $request)
  {
    return $this->start()->uri("/api/group")
        ->urlSegment($groupId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a member in a group.
   *
   * @param array $request The request object that contains all of the information used to create the group member(s).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createGroupMembers($request)
  {
    return $this->start()->uri("/api/group/member")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
   *
   * @param string $identityProviderId (Optional) The Id of the identity provider. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the identity provider.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createIdentityProvider($identityProviderId, $request)
  {
    return $this->start()->uri("/api/identity-provider")
        ->urlSegment($identityProviderId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a Lambda. You can optionally specify an Id for the lambda, if not provided one will be generated.
   *
   * @param string $lambdaId (Optional) The Id for the lambda. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the lambda.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createLambda($lambdaId, $request)
  {
    return $this->start()->uri("/api/lambda")
        ->urlSegment($lambdaId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
   *
   * @param string $tenantId (Optional) The Id for the tenant. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the tenant.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createTenant($tenantId, $request)
  {
    return $this->start()->uri("/api/tenant")
        ->urlSegment($tenantId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a Theme. You can optionally specify an Id for the theme, if not provided one will be generated.
   *
   * @param string $themeId (Optional) The Id for the theme. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the theme.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createTheme($themeId, $request)
  {
    return $this->start()->uri("/api/theme")
        ->urlSegment($themeId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
   *
   * @param string $userId (Optional) The Id for the user. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createUser($userId, $request)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after
   * that the user action can be applied to any user.
   *
   * @param string $userActionId (Optional) The Id for the user action. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the user action.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createUserAction($userActionId, $request)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a user reason. This user action reason cannot be used when actioning a user until this call completes
   * successfully. Anytime after that the user action reason can be used.
   *
   * @param string $userActionReasonId (Optional) The Id for the user action reason. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the user action reason.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createUserActionReason($userActionReasonId, $request)
  {
    return $this->start()->uri("/api/user-action-reason")
        ->urlSegment($userActionReasonId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a single User consent.
   *
   * @param string $userConsentId (Optional) The Id for the User consent. If not provided a secure random UUID will be generated.
   * @param array $request The request that contains the user consent information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createUserConsent($userConsentId, $request)
  {
    return $this->start()->uri("/api/user/consent")
        ->urlSegment($userConsentId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
   *
   * @param string $webhookId (Optional) The Id for the webhook. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the webhook.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function createWebhook($webhookId, $request)
  {
    return $this->start()->uri("/api/webhook")
        ->urlSegment($webhookId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Deactivates the application with the given Id.
   *
   * @param string $applicationId The Id of the application to deactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deactivateApplication($applicationId)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->delete()
        ->go();
  }

  /**
   * Deactivates the user with the given Id.
   *
   * @param string $userId The Id of the user to deactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deactivateUser($userId)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->delete()
        ->go();
  }

  /**
   * Deactivates the user action with the given Id.
   *
   * @param string $userActionId The Id of the user action to deactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deactivateUserAction($userActionId)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->delete()
        ->go();
  }

  /**
   * Deactivates the users with the given ids.
   *
   * @param array $userIds The ids of the users to deactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deactivateUsers($userIds)
  {
    return $this->start()->uri("/api/user/bulk")
        ->urlParameter("userId", $userIds)
        ->urlParameter("dryRun", false)
        ->urlParameter("hardDelete", false)
        ->delete()
        ->go();
  }

  /**
   * Deactivates the users found with the given search query string.
   *
   * @param string $queryString The search query string.
   * @param boolean $dryRun Whether to preview or deactivate the users found by the queryString
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deactivateUsersByQuery($queryString, $dryRun)
  {
    return $this->start()->uri("/api/user/bulk")
        ->urlParameter("queryString", $queryString)
        ->urlParameter("dryRun", $dryRun)
        ->urlParameter("hardDelete", false)
        ->delete()
        ->go();
  }

  /**
   * Hard deletes an application. This is a dangerous operation and should not be used in most circumstances. This will
   * delete the application, any registrations for that application, metrics and reports for the application, all the
   * roles for the application, and any other data associated with the application. This operation could take a very
   * long time, depending on the amount of data in your database.
   *
   * @param string $applicationId The Id of the application to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteApplication($applicationId)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlParameter("hardDelete", true)
        ->delete()
        ->go();
  }

  /**
   * Hard deletes an application role. This is a dangerous operation and should not be used in most circumstances. This
   * permanently removes the given role from all users that had it.
   *
   * @param string $applicationId The Id of the application to deactivate.
   * @param string $roleId The Id of the role to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteApplicationRole($applicationId, $roleId)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlSegment("role")
        ->urlSegment($roleId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the consent for the given Id.
   *
   * @param string $consentId The Id of the consent to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteConsent($consentId)
  {
    return $this->start()->uri("/api/consent")
        ->urlSegment($consentId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the email template for the given Id.
   *
   * @param string $emailTemplateId The Id of the email template to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteEmailTemplate($emailTemplateId)
  {
    return $this->start()->uri("/api/email/template")
        ->urlSegment($emailTemplateId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the group for the given Id.
   *
   * @param string $groupId The Id of the group to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteGroup($groupId)
  {
    return $this->start()->uri("/api/group")
        ->urlSegment($groupId)
        ->delete()
        ->go();
  }

  /**
   * Removes users as members of a group.
   *
   * @param array $request The member request that contains all of the information used to remove members to the group.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteGroupMembers($request)
  {
    return $this->start()->uri("/api/group/member")
        ->bodyHandler(new JSONBodyHandler($request))
        ->delete()
        ->go();
  }

  /**
   * Deletes the identity provider for the given Id.
   *
   * @param string $identityProviderId The Id of the identity provider to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteIdentityProvider($identityProviderId)
  {
    return $this->start()->uri("/api/identity-provider")
        ->urlSegment($identityProviderId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the key for the given Id.
   *
   * @param string $keyOd The Id of the key to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteKey($keyOd)
  {
    return $this->start()->uri("/api/key")
        ->urlSegment($keyOd)
        ->delete()
        ->go();
  }

  /**
   * Deletes the lambda for the given Id.
   *
   * @param string $lambdaId The Id of the lambda to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteLambda($lambdaId)
  {
    return $this->start()->uri("/api/lambda")
        ->urlSegment($lambdaId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the user registration for the given user and application.
   *
   * @param string $userId The Id of the user whose registration is being deleted.
   * @param string $applicationId The Id of the application to remove the registration for.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteRegistration($userId, $applicationId)
  {
    return $this->start()->uri("/api/user/registration")
        ->urlSegment($userId)
        ->urlSegment($applicationId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the tenant for the given Id.
   *
   * @param string $tenantId The Id of the tenant to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteTenant($tenantId)
  {
    return $this->start()->uri("/api/tenant")
        ->urlSegment($tenantId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the theme for the given Id.
   *
   * @param string $themeId The Id of the theme to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteTheme($themeId)
  {
    return $this->start()->uri("/api/theme")
        ->urlSegment($themeId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the user for the given Id. This permanently deletes all information, metrics, reports and data associated
   * with the user.
   *
   * @param string $userId The Id of the user to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteUser($userId)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->urlParameter("hardDelete", true)
        ->delete()
        ->go();
  }

  /**
   * Deletes the user action for the given Id. This permanently deletes the user action and also any history and logs of
   * the action being applied to any users.
   *
   * @param string $userActionId The Id of the user action to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteUserAction($userActionId)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->urlParameter("hardDelete", true)
        ->delete()
        ->go();
  }

  /**
   * Deletes the user action reason for the given Id.
   *
   * @param string $userActionReasonId The Id of the user action reason to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteUserActionReason($userActionReasonId)
  {
    return $this->start()->uri("/api/user-action-reason")
        ->urlSegment($userActionReasonId)
        ->delete()
        ->go();
  }

  /**
   * Deletes the users with the given ids, or users matching the provided queryString.
   * If you provide both userIds and queryString, the userIds will be honored.  This can be used to deactivate or hard-delete 
   * a user based on the hardDelete request body parameter.
   *
   * @param array $request The UserDeleteRequest.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteUsers($request)
  {
    return $this->start()->uri("/api/user/bulk")
        ->bodyHandler(new JSONBodyHandler($request))
        ->delete()
        ->go();
  }

  /**
   * Delete the users found with the given search query string.
   *
   * @param string $queryString The search query string.
   * @param boolean $dryRun Whether to preview or delete the users found by the queryString
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteUsersByQuery($queryString, $dryRun)
  {
    return $this->start()->uri("/api/user/bulk")
        ->urlParameter("queryString", $queryString)
        ->urlParameter("dryRun", $dryRun)
        ->urlParameter("hardDelete", true)
        ->delete()
        ->go();
  }

  /**
   * Deletes the webhook for the given Id.
   *
   * @param string $webhookId The Id of the webhook to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function deleteWebhook($webhookId)
  {
    return $this->start()->uri("/api/webhook")
        ->urlSegment($webhookId)
        ->delete()
        ->go();
  }

  /**
   * Disable Two Factor authentication for a user.
   *
   * @param string $userId The Id of the User for which you're disabling Two Factor authentication.
   * @param string $code The Two Factor code used verify the the caller knows the Two Factor secret.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function disableTwoFactor($userId, $code)
  {
    return $this->start()->uri("/api/user/two-factor")
        ->urlParameter("userId", $userId)
        ->urlParameter("code", $code)
        ->delete()
        ->go();
  }

  /**
   * Enable Two Factor authentication for a user.
   *
   * @param string $userId The Id of the user to enable Two Factor authentication.
   * @param array $request The two factor enable request information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function enableTwoFactor($userId, $request)
  {
    return $this->start()->uri("/api/user/two-factor")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Exchanges an OAuth authorization code for an access token.
   * If you will be using the Authorization Code grant, you will make a request to the Token endpoint to exchange the authorization code returned from the Authorize endpoint for an access token.
   *
   * @param string $code The authorization code returned on the /oauth2/authorize response.
   * @param string $client_id (Optional) The unique client identifier. The client Id is the Id of the FusionAuth Application in which you you are attempting to authenticate. This parameter is optional when the Authorization header is provided.
   * @param string $client_secret (Optional) The client secret. This value may optionally be provided in the request body instead of the Authorization header.
   * @param string $redirect_uri The URI to redirect to upon a successful request.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function exchangeOAuthCodeForAccessToken($code, $client_id, $client_secret, $redirect_uri)
  {
    $post_data = array(
      'code' => $code,
      'client_id' => $client_id,
      'client_secret' => $client_secret,
      'grant_type' => 'authorization_code',
      'redirect_uri' => $redirect_uri
    );
    return $this->startAnonymous()->uri("/oauth2/token")
        ->bodyHandler(new FormDataBodyHandler($post_data))
        ->post()
        ->go();
  }

  /**
   * Exchange a Refresh Token for an Access Token.
   * If you will be using the Refresh Token Grant, you will make a request to the Token endpoint to exchange the user’s refresh token for an access token.
   *
   * @param string $refresh_token The refresh token that you would like to use to exchange for an access token.
   * @param string $client_id (Optional) The unique client identifier. The client Id is the Id of the FusionAuth Application in which you you are attempting to authenticate. This parameter is optional when the Authorization header is provided.
   * @param string $client_secret (Optional) The client secret. This value may optionally be provided in the request body instead of the Authorization header.
   * @param string $scope (Optional) This parameter is optional and if omitted, the same scope requested during the authorization request will be used. If provided the scopes must match those requested during the initial authorization request.
   * @param string $user_code (Optional) The end-user verification code. This code is required if using this endpoint to approve the Device Authorization.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function exchangeRefreshTokenForAccessToken($refresh_token, $client_id, $client_secret, $scope, $user_code = NULL)
  {
    $post_data = array(
      'refresh_token' => $refresh_token,
      'client_id' => $client_id,
      'client_secret' => $client_secret,
      'grant_type' => 'refresh_token',
      'scope' => $scope,
      'user_code' => $user_code
    );
    return $this->startAnonymous()->uri("/oauth2/token")
        ->bodyHandler(new FormDataBodyHandler($post_data))
        ->post()
        ->go();
  }

  /**
   * Exchange a refresh token for a new JWT.
   *
   * @param array $request The refresh request.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function exchangeRefreshTokenForJWT($request)
  {
    return $this->startAnonymous()->uri("/api/jwt/refresh")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Exchange User Credentials for a Token.
   * If you will be using the Resource Owner Password Credential Grant, you will make a request to the Token endpoint to exchange the user’s email and password for an access token.
   *
   * @param string $username The login identifier of the user. The login identifier can be either the email or the username.
   * @param string $password The user’s password.
   * @param string $client_id (Optional) The unique client identifier. The client Id is the Id of the FusionAuth Application in which you you are attempting to authenticate. This parameter is optional when the Authorization header is provided.
   * @param string $client_secret (Optional) The client secret. This value may optionally be provided in the request body instead of the Authorization header.
   * @param string $scope (Optional) This parameter is optional and if omitted, the same scope requested during the authorization request will be used. If provided the scopes must match those requested during the initial authorization request.
   * @param string $user_code (Optional) The end-user verification code. This code is required if using this endpoint to approve the Device Authorization.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function exchangeUserCredentialsForAccessToken($username, $password, $client_id, $client_secret, $scope, $user_code = NULL)
  {
    $post_data = array(
      'username' => $username,
      'password' => $password,
      'client_id' => $client_id,
      'client_secret' => $client_secret,
      'grant_type' => 'password',
      'scope' => $scope,
      'user_code' => $user_code
    );
    return $this->startAnonymous()->uri("/oauth2/token")
        ->bodyHandler(new FormDataBodyHandler($post_data))
        ->post()
        ->go();
  }

  /**
   * Begins the forgot password sequence, which kicks off an email to the user so that they can reset their password.
   *
   * @param array $request The request that contains the information about the user so that they can be emailed.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function forgotPassword($request)
  {
    return $this->startAnonymous()->uri("/api/user/forgot-password")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Generate a new Email Verification Id to be used with the Verify Email API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param string $email The email address of the user that needs a new verification email.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function generateEmailVerificationId($email)
  {
    return $this->start()->uri("/api/user/verify-email")
        ->urlParameter("email", $email)
        ->urlParameter("sendVerifyEmail", false)
        ->put()
        ->go();
  }

  /**
   * Generate a new RSA or EC key pair or an HMAC secret.
   *
   * @param string $keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the key.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function generateKey($keyId, $request)
  {
    return $this->start()->uri("/api/key/generate")
        ->urlSegment($keyId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Generate a new Application Registration Verification Id to be used with the Verify Registration API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param string $email The email address of the user that needs a new verification email.
   * @param string $applicationId The Id of the application to be verified.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function generateRegistrationVerificationId($email, $applicationId)
  {
    return $this->start()->uri("/api/user/verify-registration")
        ->urlParameter("email", $email)
        ->urlParameter("sendVerifyPasswordEmail", false)
        ->urlParameter("applicationId", $applicationId)
        ->put()
        ->go();
  }

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function generateTwoFactorSecret()
  {
    return $this->start()->uri("/api/two-factor/secret")
        ->get()
        ->go();
  }

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @param string $encodedJWT The encoded JWT (access token).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function generateTwoFactorSecretUsingJWT($encodedJWT)
  {
    return $this->start()->uri("/api/two-factor/secret")
        ->authorization("JWT " . $encodedJWT)
        ->get()
        ->go();
  }

  /**
   * Handles login via third-parties including Social login, external OAuth and OpenID Connect, and other
   * login systems.
   *
   * @param array $request The third-party login request that contains information from the third-party login
  *     providers that FusionAuth uses to reconcile the user's account.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function identityProviderLogin($request)
  {
    return $this->startAnonymous()->uri("/api/identity-provider/login")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Import an existing RSA or EC key pair or an HMAC secret.
   *
   * @param string $keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
   * @param array $request The request object that contains all of the information used to create the key.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function importKey($keyId, $request)
  {
    return $this->start()->uri("/api/key/import")
        ->urlSegment($keyId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Bulk imports multiple users. This does some validation, but then tries to run batch inserts of users. This reduces
   * latency when inserting lots of users. Therefore, the error response might contain some information about failures,
   * but it will likely be pretty generic.
   *
   * @param array $request The request that contains all of the information about all of the users to import.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function importUsers($request)
  {
    return $this->start()->uri("/api/user/import")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is valid. A valid
   * access token is properly signed and not expired.
   * <p>
   * This API may be used in an SSO configuration to issue new tokens for another application after the user has
   * obtained a valid token from authentication.
   *
   * @param string $applicationId The Application Id for which you are requesting a new access token be issued.
   * @param string $encodedJWT The encoded JWT (access token).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function issueJWT($applicationId, $encodedJWT)
  {
    return $this->start()->uri("/api/jwt/issue")
        ->authorization("JWT " . $encodedJWT)
        ->urlParameter("applicationId", $applicationId)
        ->get()
        ->go();
  }

  /**
   * Authenticates a user to FusionAuth. 
   * 
   * This API optionally requires an API key. See <code>Application.loginConfiguration.requireAuthentication</code>.
   *
   * @param array $request The login request that contains the user credentials used to log them in.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function login($request)
  {
    return $this->start()->uri("/api/login")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using
   * FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an
   * application where they no longer have a session. This helps correctly track login counts, times and helps with
   * reporting.
   *
   * @param string $userId The Id of the user that was logged in.
   * @param string $applicationId The Id of the application that they logged into.
   * @param string $callerIPAddress (Optional) The IP address of the end-user that is logging in. If a null value is provided
  *     the IP address will be that of the client or last proxy that sent the request.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function loginPing($userId, $applicationId, $callerIPAddress = NULL)
  {
    return $this->start()->uri("/api/login")
        ->urlSegment($userId)
        ->urlSegment($applicationId)
        ->urlParameter("ipAddress", $callerIPAddress)
        ->put()
        ->go();
  }

  /**
   * The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the
   * client and revoke the refresh token stored. This API does nothing if the request does not contain an access
   * token or refresh token cookies.
   *
   * @param boolean $global When this value is set to true all of the refresh tokens issued to the owner of the
  *     provided token will be revoked.
   * @param string $refreshToken (Optional) The refresh_token as a request parameter instead of coming in via a cookie.
  *     If provided this takes precedence over the cookie.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function logout($global, $refreshToken = NULL)
  {
    return $this->startAnonymous()->uri("/api/logout")
        ->urlParameter("global", $global)
        ->urlParameter("refreshToken", $refreshToken)
        ->post()
        ->go();
  }

  /**
   * Retrieves the identity provider for the given domain. A 200 response code indicates the domain is managed
   * by a registered identity provider. A 404 indicates the domain is not managed.
   *
   * @param string $domain The domain or email address to lookup.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function lookupIdentityProvider($domain)
  {
    return $this->start()->uri("/api/identity-provider/lookup")
        ->urlParameter("domain", $domain)
        ->get()
        ->go();
  }

  /**
   * Modifies a temporal user action by changing the expiration of the action and optionally adding a comment to the
   * action.
   *
   * @param string $actionId The Id of the action to modify. This is technically the user action log id.
   * @param array $request The request that contains all of the information about the modification.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function modifyAction($actionId, $request)
  {
    return $this->start()->uri("/api/user/action")
        ->urlSegment($actionId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Complete a login request using a passwordless code
   *
   * @param array $request The passwordless login request that contains all of the information used to complete login.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function passwordlessLogin($request)
  {
    return $this->startAnonymous()->uri("/api/passwordless/login")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Updates, via PATCH, the application with the given Id.
   *
   * @param string $applicationId The Id of the application to update.
   * @param array $request The request that contains just the new application information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchApplication($applicationId, $request)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the application role with the given id for the application.
   *
   * @param string $applicationId The Id of the application that the role belongs to.
   * @param string $roleId The Id of the role to update.
   * @param array $request The request that contains just the new role information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchApplicationRole($applicationId, $roleId, $request)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlSegment("role")
        ->urlSegment($roleId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the consent with the given Id.
   *
   * @param string $consentId The Id of the consent to update.
   * @param array $request The request that contains just the new consent information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchConsent($consentId, $request)
  {
    return $this->start()->uri("/api/consent")
        ->urlSegment($consentId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the email template with the given Id.
   *
   * @param string $emailTemplateId The Id of the email template to update.
   * @param array $request The request that contains just the new email template information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchEmailTemplate($emailTemplateId, $request)
  {
    return $this->start()->uri("/api/email/template")
        ->urlSegment($emailTemplateId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the group with the given Id.
   *
   * @param string $groupId The Id of the group to update.
   * @param array $request The request that contains just the new group information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchGroup($groupId, $request)
  {
    return $this->start()->uri("/api/group")
        ->urlSegment($groupId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the identity provider with the given Id.
   *
   * @param string $identityProviderId The Id of the identity provider to update.
   * @param array $request The request object that contains just the updated identity provider information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchIdentityProvider($identityProviderId, $request)
  {
    return $this->start()->uri("/api/identity-provider")
        ->urlSegment($identityProviderId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the available integrations.
   *
   * @param array $request The request that contains just the new integration information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchIntegrations($request)
  {
    return $this->start()->uri("/api/integration")
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the lambda with the given Id.
   *
   * @param string $lambdaId The Id of the lambda to update.
   * @param array $request The request that contains just the new lambda information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchLambda($lambdaId, $request)
  {
    return $this->start()->uri("/api/lambda")
        ->urlSegment($lambdaId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the registration for the user with the given id and the application defined in the request.
   *
   * @param string $userId The Id of the user whose registration is going to be updated.
   * @param array $request The request that contains just the new registration information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchRegistration($userId, $request)
  {
    return $this->start()->uri("/api/user/registration")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the system configuration.
   *
   * @param array $request The request that contains just the new system configuration information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchSystemConfiguration($request)
  {
    return $this->start()->uri("/api/system-configuration")
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the tenant with the given Id.
   *
   * @param string $tenantId The Id of the tenant to update.
   * @param array $request The request that contains just the new tenant information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchTenant($tenantId, $request)
  {
    return $this->start()->uri("/api/tenant")
        ->urlSegment($tenantId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the theme with the given Id.
   *
   * @param string $themeId The Id of the theme to update.
   * @param array $request The request that contains just the new theme information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchTheme($themeId, $request)
  {
    return $this->start()->uri("/api/theme")
        ->urlSegment($themeId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the user with the given Id.
   *
   * @param string $userId The Id of the user to update.
   * @param array $request The request that contains just the new user information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchUser($userId, $request)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the user action with the given Id.
   *
   * @param string $userActionId The Id of the user action to update.
   * @param array $request The request that contains just the new user action information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchUserAction($userActionId, $request)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, the user action reason with the given Id.
   *
   * @param string $userActionReasonId The Id of the user action reason to update.
   * @param array $request The request that contains just the new user action reason information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchUserActionReason($userActionReasonId, $request)
  {
    return $this->start()->uri("/api/user-action-reason")
        ->urlSegment($userActionReasonId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Updates, via PATCH, a single User consent by Id.
   *
   * @param string $userConsentId The User Consent Id
   * @param array $request The request that contains just the new user consent information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function patchUserConsent($userConsentId, $request)
  {
    return $this->start()->uri("/api/user/consent")
        ->urlSegment($userConsentId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->patch()
        ->go();
  }

  /**
   * Reactivates the application with the given Id.
   *
   * @param string $applicationId The Id of the application to reactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function reactivateApplication($applicationId)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlParameter("reactivate", true)
        ->put()
        ->go();
  }

  /**
   * Reactivates the user with the given Id.
   *
   * @param string $userId The Id of the user to reactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function reactivateUser($userId)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->urlParameter("reactivate", true)
        ->put()
        ->go();
  }

  /**
   * Reactivates the user action with the given Id.
   *
   * @param string $userActionId The Id of the user action to reactivate.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function reactivateUserAction($userActionId)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->urlParameter("reactivate", true)
        ->put()
        ->go();
  }

  /**
   * Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
   *
   * @param array $request The reconcile request that contains the data to reconcile the User.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function reconcileJWT($request)
  {
    return $this->startAnonymous()->uri("/api/jwt/reconcile")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Request a refresh of the User search index. This API is not generally necessary and the search index will become consistent in a
   * reasonable amount of time. There may be scenarios where you may wish to manually request an index refresh. One example may be 
   * if you are using the Search API or Delete Tenant API immediately following a User Create etc, you may wish to request a refresh to
   *  ensure the index immediately current before making a query request to the search index.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function refreshUserSearchIndex()
  {
    return $this->start()->uri("/api/user/search")
        ->put()
        ->go();
  }

  /**
   * Registers a user for an application. If you provide the User and the UserRegistration object on this request, it
   * will create the user as well as register them for the application. This is called a Full Registration. However, if
   * you only provide the UserRegistration object, then the user must already exist and they will be registered for the
   * application. The user id can also be provided and it will either be used to look up an existing user or it will be
   * used for the newly created User.
   *
   * @param string $userId (Optional) The Id of the user being registered for the application and optionally created.
   * @param array $request The request that optionally contains the User and must contain the UserRegistration.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function register($userId, $request)
  {
    return $this->start()->uri("/api/user/registration")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Removes a user from the family with the given id.
   *
   * @param string $familyId The id of the family to remove the user from.
   * @param string $userId The id of the user to remove from the family.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function removeUserFromFamily($familyId, $userId)
  {
    return $this->start()->uri("/api/user/family")
        ->urlSegment($familyId)
        ->urlSegment($userId)
        ->delete()
        ->go();
  }

  /**
   * Re-sends the verification email to the user.
   *
   * @param string $email The email address of the user that needs a new verification email.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function resendEmailVerification($email)
  {
    return $this->startAnonymous()->uri("/api/user/verify-email")
        ->urlParameter("email", $email)
        ->put()
        ->go();
  }

  /**
   * Re-sends the application registration verification email to the user.
   *
   * @param string $email The email address of the user that needs a new verification email.
   * @param string $applicationId The Id of the application to be verified.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function resendRegistrationVerification($email, $applicationId)
  {
    return $this->startAnonymous()->uri("/api/user/verify-registration")
        ->urlParameter("email", $email)
        ->urlParameter("applicationId", $applicationId)
        ->put()
        ->go();
  }

  /**
   * Retrieves a single action log (the log of a user action that was taken on a user previously) for the given Id.
   *
   * @param string $actionId The Id of the action to retrieve.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveAction($actionId)
  {
    return $this->start()->uri("/api/user/action")
        ->urlSegment($actionId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the actions for the user with the given Id. This will return all time based actions that are active,
   * and inactive as well as non-time based actions.
   *
   * @param string $userId The Id of the user to fetch the actions for.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveActions($userId)
  {
    return $this->start()->uri("/api/user/action")
        ->urlParameter("userId", $userId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the actions for the user with the given Id that are currently preventing the User from logging in.
   *
   * @param string $userId The Id of the user to fetch the actions for.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveActionsPreventingLogin($userId)
  {
    return $this->start()->uri("/api/user/action")
        ->urlParameter("userId", $userId)
        ->urlParameter("preventingLogin", true)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the actions for the user with the given Id that are currently active.
   * An active action means one that is time based and has not been canceled, and has not ended.
   *
   * @param string $userId The Id of the user to fetch the actions for.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveActiveActions($userId)
  {
    return $this->start()->uri("/api/user/action")
        ->urlParameter("userId", $userId)
        ->urlParameter("active", true)
        ->get()
        ->go();
  }

  /**
   * Retrieves the application for the given id or all of the applications if the id is null.
   *
   * @param string $applicationId (Optional) The application id.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveApplication($applicationId = NULL)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the applications.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveApplications()
  {
    return $this->start()->uri("/api/application")
        ->get()
        ->go();
  }

  /**
   * Retrieves a single audit log for the given Id.
   *
   * @param int $auditLogId The Id of the audit log to retrieve.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveAuditLog($auditLogId)
  {
    return $this->start()->uri("/api/system/audit-log")
        ->urlSegment($auditLogId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the Consent for the given Id.
   *
   * @param string $consentId The Id of the consent.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveConsent($consentId)
  {
    return $this->start()->uri("/api/consent")
        ->urlSegment($consentId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the consent.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveConsents()
  {
    return $this->start()->uri("/api/consent")
        ->get()
        ->go();
  }

  /**
   * Retrieves the daily active user report between the two instants. If you specify an application id, it will only
   * return the daily active counts for that application.
   *
   * @param string $applicationId (Optional) The application id.
   * @param array $start The start instant as UTC milliseconds since Epoch.
   * @param array $end The end instant as UTC milliseconds since Epoch.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveDailyActiveReport($applicationId, $start, $end)
  {
    return $this->start()->uri("/api/report/daily-active-user")
        ->urlParameter("applicationId", $applicationId)
        ->urlParameter("start", $start)
        ->urlParameter("end", $end)
        ->get()
        ->go();
  }

  /**
   * Retrieves the email template for the given Id. If you don't specify the id, this will return all of the email templates.
   *
   * @param string $emailTemplateId (Optional) The Id of the email template.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveEmailTemplate($emailTemplateId = NULL)
  {
    return $this->start()->uri("/api/email/template")
        ->urlSegment($emailTemplateId)
        ->get()
        ->go();
  }

  /**
   * Creates a preview of the email template provided in the request. This allows you to preview an email template that
   * hasn't been saved to the database yet. The entire email template does not need to be provided on the request. This
   * will create the preview based on whatever is given.
   *
   * @param array $request The request that contains the email template and optionally a locale to render it in.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveEmailTemplatePreview($request)
  {
    return $this->start()->uri("/api/email/template/preview")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Retrieves all of the email templates.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveEmailTemplates()
  {
    return $this->start()->uri("/api/email/template")
        ->get()
        ->go();
  }

  /**
   * Retrieves a single event log for the given Id.
   *
   * @param int $eventLogId The Id of the event log to retrieve.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveEventLog($eventLogId)
  {
    return $this->start()->uri("/api/system/event-log")
        ->urlSegment($eventLogId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the families that a user belongs to.
   *
   * @param string $userId The User's id
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveFamilies($userId)
  {
    return $this->start()->uri("/api/user/family")
        ->urlParameter("userId", $userId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the members of a family by the unique Family Id.
   *
   * @param string $familyId The unique Id of the Family.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveFamilyMembersByFamilyId($familyId)
  {
    return $this->start()->uri("/api/user/family")
        ->urlSegment($familyId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the group for the given Id.
   *
   * @param string $groupId The Id of the group.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveGroup($groupId)
  {
    return $this->start()->uri("/api/group")
        ->urlSegment($groupId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the groups.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveGroups()
  {
    return $this->start()->uri("/api/group")
        ->get()
        ->go();
  }

  /**
   * Retrieves the identity provider for the given id or all of the identity providers if the id is null.
   *
   * @param string $identityProviderId (Optional) The identity provider id.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveIdentityProvider($identityProviderId = NULL)
  {
    return $this->start()->uri("/api/identity-provider")
        ->urlSegment($identityProviderId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the identity providers.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveIdentityProviders()
  {
    return $this->start()->uri("/api/identity-provider")
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the actions for the user with the given Id that are currently inactive.
   * An inactive action means one that is time based and has been canceled or has expired, or is not time based.
   *
   * @param string $userId The Id of the user to fetch the actions for.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveInactiveActions($userId)
  {
    return $this->start()->uri("/api/user/action")
        ->urlParameter("userId", $userId)
        ->urlParameter("active", false)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the applications that are currently inactive.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveInactiveApplications()
  {
    return $this->start()->uri("/api/application")
        ->urlParameter("inactive", true)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the user actions that are currently inactive.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveInactiveUserActions()
  {
    return $this->start()->uri("/api/user-action")
        ->urlParameter("inactive", true)
        ->get()
        ->go();
  }

  /**
   * Retrieves the available integrations.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveIntegration()
  {
    return $this->start()->uri("/api/integration")
        ->get()
        ->go();
  }

  /**
   * Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by the key Id (kid).
   *
   * @param string $keyId The Id of the public key (kid).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveJWTPublicKey($keyId)
  {
    return $this->startAnonymous()->uri("/api/jwt/public-key")
        ->urlParameter("kid", $keyId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the Public Key configured for verifying the JSON Web Tokens (JWT) issued by the Login API by the Application Id.
   *
   * @param string $applicationId The Id of the Application for which this key is used.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveJWTPublicKeyByApplicationId($applicationId)
  {
    return $this->startAnonymous()->uri("/api/jwt/public-key")
        ->urlParameter("applicationId", $applicationId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all Public Keys configured for verifying JSON Web Tokens (JWT).
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveJWTPublicKeys()
  {
    return $this->startAnonymous()->uri("/api/jwt/public-key")
        ->get()
        ->go();
  }

  /**
   * Returns public keys used by FusionAuth to cryptographically verify JWTs using the JSON Web Key format.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveJsonWebKeySet()
  {
    return $this->startAnonymous()->uri("/.well-known/jwks.json")
        ->get()
        ->go();
  }

  /**
   * Retrieves the key for the given Id.
   *
   * @param string $keyId The Id of the key.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveKey($keyId)
  {
    return $this->start()->uri("/api/key")
        ->urlSegment($keyId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the keys.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveKeys()
  {
    return $this->start()->uri("/api/key")
        ->get()
        ->go();
  }

  /**
   * Retrieves the lambda for the given Id.
   *
   * @param string $lambdaId The Id of the lambda.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveLambda($lambdaId)
  {
    return $this->start()->uri("/api/lambda")
        ->urlSegment($lambdaId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the lambdas.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveLambdas()
  {
    return $this->start()->uri("/api/lambda")
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the lambdas for the provided type.
   *
   * @param array $type The type of the lambda to return.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveLambdasByType($type)
  {
    return $this->start()->uri("/api/lambda")
        ->urlParameter("type", $type)
        ->get()
        ->go();
  }

  /**
   * Retrieves the login report between the two instants. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param string $applicationId (Optional) The application id.
   * @param array $start The start instant as UTC milliseconds since Epoch.
   * @param array $end The end instant as UTC milliseconds since Epoch.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveLoginReport($applicationId, $start, $end)
  {
    return $this->start()->uri("/api/report/login")
        ->urlParameter("applicationId", $applicationId)
        ->urlParameter("start", $start)
        ->urlParameter("end", $end)
        ->get()
        ->go();
  }

  /**
   * Retrieves the monthly active user report between the two instants. If you specify an application id, it will only
   * return the monthly active counts for that application.
   *
   * @param string $applicationId (Optional) The application id.
   * @param array $start The start instant as UTC milliseconds since Epoch.
   * @param array $end The end instant as UTC milliseconds since Epoch.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveMonthlyActiveReport($applicationId, $start, $end)
  {
    return $this->start()->uri("/api/report/monthly-active-user")
        ->urlParameter("applicationId", $applicationId)
        ->urlParameter("start", $start)
        ->urlParameter("end", $end)
        ->get()
        ->go();
  }

  /**
   * Retrieves the Oauth2 configuration for the application for the given Application Id.
   *
   * @param string $applicationId The Id of the Application to retrieve OAuth configuration.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveOauthConfiguration($applicationId)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlSegment("oauth-configuration")
        ->get()
        ->go();
  }

  /**
   * Returns the well known OpenID Configuration JSON document
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveOpenIdConfiguration()
  {
    return $this->startAnonymous()->uri("/.well-known/openid-configuration")
        ->get()
        ->go();
  }

  /**
   * Retrieves the password validation rules for a specific tenant. This method requires a tenantId to be provided 
   * through the use of a Tenant scoped API key or an HTTP header X-FusionAuth-TenantId to specify the Tenant Id.
   * 
   * This API does not require an API key.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrievePasswordValidationRules()
  {
    return $this->startAnonymous()->uri("/api/tenant/password-validation-rules")
        ->get()
        ->go();
  }

  /**
   * Retrieves the password validation rules for a specific tenant.
   * 
   * This API does not require an API key.
   *
   * @param string $tenantId The Id of the tenant.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrievePasswordValidationRulesWithTenantId($tenantId)
  {
    return $this->startAnonymous()->uri("/api/tenant/password-validation-rules")
        ->urlSegment($tenantId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the children for the given parent email address.
   *
   * @param string $parentEmail The email of the parent.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrievePendingChildren($parentEmail)
  {
    return $this->start()->uri("/api/user/family/pending")
        ->urlParameter("parentEmail", $parentEmail)
        ->get()
        ->go();
  }

  /**
   * Retrieves the last number of login records.
   *
   * @param int $offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param int $limit (Optional, defaults to 10) The number of records to retrieve.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveRecentLogins($offset, $limit)
  {
    return $this->start()->uri("/api/user/recent-login")
        ->urlParameter("offset", $offset)
        ->urlParameter("limit", $limit)
        ->get()
        ->go();
  }

  /**
   * Retrieves the refresh tokens that belong to the user with the given Id.
   *
   * @param string $userId The Id of the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveRefreshTokens($userId)
  {
    return $this->start()->uri("/api/jwt/refresh")
        ->urlParameter("userId", $userId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user registration for the user with the given id and the given application id.
   *
   * @param string $userId The Id of the user.
   * @param string $applicationId The Id of the application.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveRegistration($userId, $applicationId)
  {
    return $this->start()->uri("/api/user/registration")
        ->urlSegment($userId)
        ->urlSegment($applicationId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the registration report between the two instants. If you specify an application id, it will only return
   * the registration counts for that application.
   *
   * @param string $applicationId (Optional) The application id.
   * @param array $start The start instant as UTC milliseconds since Epoch.
   * @param array $end The end instant as UTC milliseconds since Epoch.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveRegistrationReport($applicationId, $start, $end)
  {
    return $this->start()->uri("/api/report/registration")
        ->urlParameter("applicationId", $applicationId)
        ->urlParameter("start", $start)
        ->urlParameter("end", $end)
        ->get()
        ->go();
  }

  /**
   * Retrieves the system configuration.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveSystemConfiguration()
  {
    return $this->start()->uri("/api/system-configuration")
        ->get()
        ->go();
  }

  /**
   * Retrieves the tenant for the given Id.
   *
   * @param string $tenantId The Id of the tenant.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveTenant($tenantId)
  {
    return $this->start()->uri("/api/tenant")
        ->urlSegment($tenantId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the tenants.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveTenants()
  {
    return $this->start()->uri("/api/tenant")
        ->get()
        ->go();
  }

  /**
   * Retrieves the theme for the given Id.
   *
   * @param string $themeId The Id of the theme.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveTheme($themeId)
  {
    return $this->start()->uri("/api/theme")
        ->urlSegment($themeId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the themes.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveThemes()
  {
    return $this->start()->uri("/api/theme")
        ->get()
        ->go();
  }

  /**
   * Retrieves the totals report. This contains all of the total counts for each application and the global registration
   * count.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveTotalReport()
  {
    return $this->start()->uri("/api/report/totals")
        ->get()
        ->go();
  }

  /**
   * Retrieves the user for the given Id.
   *
   * @param string $userId The Id of the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUser($userId)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user action for the given Id. If you pass in null for the id, this will return all of the user
   * actions.
   *
   * @param string $userActionId (Optional) The Id of the user action.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserAction($userActionId = NULL)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user action reason for the given Id. If you pass in null for the id, this will return all of the user
   * action reasons.
   *
   * @param string $userActionReasonId (Optional) The Id of the user action reason.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserActionReason($userActionReasonId = NULL)
  {
    return $this->start()->uri("/api/user-action-reason")
        ->urlSegment($userActionReasonId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all the user action reasons.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserActionReasons()
  {
    return $this->start()->uri("/api/user-action-reason")
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the user actions.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserActions()
  {
    return $this->start()->uri("/api/user-action")
        ->get()
        ->go();
  }

  /**
   * Retrieves the user by a change password Id. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param string $changePasswordId The unique change password Id that was sent via email or returned by the Forgot Password API.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserByChangePasswordId($changePasswordId)
  {
    return $this->start()->uri("/api/user")
        ->urlParameter("changePasswordId", $changePasswordId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user for the given email.
   *
   * @param string $email The email of the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserByEmail($email)
  {
    return $this->start()->uri("/api/user")
        ->urlParameter("email", $email)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user for the loginId. The loginId can be either the username or the email.
   *
   * @param string $loginId The email or username of the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserByLoginId($loginId)
  {
    return $this->start()->uri("/api/user")
        ->urlParameter("loginId", $loginId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user for the given username.
   *
   * @param string $username The username of the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserByUsername($username)
  {
    return $this->start()->uri("/api/user")
        ->urlParameter("username", $username)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user by a verificationId. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param string $verificationId The unique verification Id that has been set on the user object.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserByVerificationId($verificationId)
  {
    return $this->start()->uri("/api/user")
        ->urlParameter("verificationId", $verificationId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the comments for the user with the given Id.
   *
   * @param string $userId The Id of the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserComments($userId)
  {
    return $this->start()->uri("/api/user/comment")
        ->urlSegment($userId)
        ->get()
        ->go();
  }

  /**
   * Retrieve a single User consent by Id.
   *
   * @param string $userConsentId The User consent Id
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserConsent($userConsentId)
  {
    return $this->start()->uri("/api/user/consent")
        ->urlSegment($userConsentId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all of the consents for a User.
   *
   * @param string $userId The User's Id
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserConsents($userId)
  {
    return $this->start()->uri("/api/user/consent")
        ->urlParameter("userId", $userId)
        ->get()
        ->go();
  }

  /**
   * Retrieves the login report between the two instants for a particular user by Id. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param string $applicationId (Optional) The application id.
   * @param string $userId The userId id.
   * @param array $start The start instant as UTC milliseconds since Epoch.
   * @param array $end The end instant as UTC milliseconds since Epoch.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserLoginReport($applicationId, $userId, $start, $end)
  {
    return $this->start()->uri("/api/report/login")
        ->urlParameter("applicationId", $applicationId)
        ->urlParameter("userId", $userId)
        ->urlParameter("start", $start)
        ->urlParameter("end", $end)
        ->get()
        ->go();
  }

  /**
   * Retrieves the login report between the two instants for a particular user by login Id. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param string $applicationId (Optional) The application id.
   * @param string $loginId The userId id.
   * @param array $start The start instant as UTC milliseconds since Epoch.
   * @param array $end The end instant as UTC milliseconds since Epoch.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserLoginReportByLoginId($applicationId, $loginId, $start, $end)
  {
    return $this->start()->uri("/api/report/login")
        ->urlParameter("applicationId", $applicationId)
        ->urlParameter("loginId", $loginId)
        ->urlParameter("start", $start)
        ->urlParameter("end", $end)
        ->get()
        ->go();
  }

  /**
   * Retrieves the last number of login records for a user.
   *
   * @param string $userId The Id of the user.
   * @param int $offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param int $limit (Optional, defaults to 10) The number of records to retrieve.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserRecentLogins($userId, $offset, $limit)
  {
    return $this->start()->uri("/api/user/recent-login")
        ->urlParameter("userId", $userId)
        ->urlParameter("offset", $offset)
        ->urlParameter("limit", $limit)
        ->get()
        ->go();
  }

  /**
   * Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web Token (JWT) for authentication.
   *
   * @param string $encodedJWT The encoded JWT (access token).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveUserUsingJWT($encodedJWT)
  {
    return $this->startAnonymous()->uri("/api/user")
        ->authorization("JWT " . $encodedJWT)
        ->get()
        ->go();
  }

  /**
   * Retrieves the webhook for the given Id. If you pass in null for the id, this will return all the webhooks.
   *
   * @param string $webhookId (Optional) The Id of the webhook.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveWebhook($webhookId = NULL)
  {
    return $this->start()->uri("/api/webhook")
        ->urlSegment($webhookId)
        ->get()
        ->go();
  }

  /**
   * Retrieves all the webhooks.
   *
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function retrieveWebhooks()
  {
    return $this->start()->uri("/api/webhook")
        ->get()
        ->go();
  }

  /**
   * Revokes a single refresh token, all tokens for a user or all tokens for an application. If you provide a user id
   * and an application id, this will delete all the refresh tokens for that user for that application.
   *
   * @param string $token (Optional) The refresh token to delete.
   * @param string $userId (Optional) The user id whose tokens to delete.
   * @param string $applicationId (Optional) The application id of the tokens to delete.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function revokeRefreshToken($token, $userId, $applicationId = NULL)
  {
    return $this->start()->uri("/api/jwt/refresh")
        ->urlParameter("token", $token)
        ->urlParameter("userId", $userId)
        ->urlParameter("applicationId", $applicationId)
        ->delete()
        ->go();
  }

  /**
   * Revokes a single User consent by Id.
   *
   * @param string $userConsentId The User Consent Id
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function revokeUserConsent($userConsentId)
  {
    return $this->start()->uri("/api/user/consent")
        ->urlSegment($userConsentId)
        ->delete()
        ->go();
  }

  /**
   * Searches the audit logs with the specified criteria and pagination.
   *
   * @param array $request The search criteria and pagination information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function searchAuditLogs($request)
  {
    return $this->start()->uri("/api/system/audit-log/search")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Searches the event logs with the specified criteria and pagination.
   *
   * @param array $request The search criteria and pagination information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function searchEventLogs($request)
  {
    return $this->start()->uri("/api/system/event-log/search")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Searches the login records with the specified criteria and pagination.
   *
   * @param array $request The search criteria and pagination information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function searchLoginRecords($request)
  {
    return $this->start()->uri("/api/system/login-record/search")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Retrieves the users for the given ids. If any id is invalid, it is ignored.
   *
   * @param array $ids The user ids to search for.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function searchUsers($ids)
  {
    return $this->start()->uri("/api/user/search")
        ->urlParameter("ids", $ids)
        ->get()
        ->go();
  }

  /**
   * Retrieves the users for the given search criteria and pagination.
   *
   * @param array $request The search criteria and pagination constraints. Fields used: queryString, numberOfResults, startRow,
  *     and sort fields.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function searchUsersByQueryString($request)
  {
    return $this->start()->uri("/api/user/search")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Send an email using an email template id. You can optionally provide <code>requestData</code> to access key value
   * pairs in the email template.
   *
   * @param string $emailTemplateId The id for the template.
   * @param array $request The send email request that contains all of the information used to send the email.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function sendEmail($emailTemplateId, $request)
  {
    return $this->start()->uri("/api/email/send")
        ->urlSegment($emailTemplateId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Sends out an email to a parent that they need to register and create a family or need to log in and add a child to their existing family.
   *
   * @param array $request The request object that contains the parent email.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function sendFamilyRequestEmail($request)
  {
    return $this->start()->uri("/api/user/family/request")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Send a passwordless authentication code in an email to complete login.
   *
   * @param array $request The passwordless send request that contains all of the information used to send an email containing a code.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function sendPasswordlessCode($request)
  {
    return $this->startAnonymous()->uri("/api/passwordless/send")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Send a Two Factor authentication code to assist in setting up Two Factor authentication or disabling.
   *
   * @param array $request The request object that contains all of the information used to send the code.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function sendTwoFactorCode($request)
  {
    return $this->start()->uri("/api/two-factor/send")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Send a Two Factor authentication code to allow the completion of Two Factor authentication.
   *
   * @param string $twoFactorId The Id returned by the Login API necessary to complete Two Factor authentication.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function sendTwoFactorCodeForLogin($twoFactorId)
  {
    return $this->startAnonymous()->uri("/api/two-factor/send")
        ->urlSegment($twoFactorId)
        ->post()
        ->go();
  }

  /**
   * Begins a login request for a 3rd party login that requires user interaction such as HYPR.
   *
   * @param array $request The third-party login request that contains information from the third-party login
  *     providers that FusionAuth uses to reconcile the user's account.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function startIdentityProviderLogin($request)
  {
    return $this->start()->uri("/api/identity-provider/start")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Start a passwordless login request by generating a passwordless code. This code can be sent to the User using the Send
   * Passwordless Code API or using a mechanism outside of FusionAuth. The passwordless login is completed by using the Passwordless Login API with this code.
   *
   * @param array $request The passwordless start request that contains all of the information used to begin the passwordless login request.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function startPasswordlessLogin($request)
  {
    return $this->start()->uri("/api/passwordless/start")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Complete login using a 2FA challenge
   *
   * @param array $request The login request that contains the user credentials used to log them in.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function twoFactorLogin($request)
  {
    return $this->startAnonymous()->uri("/api/two-factor/login")
        ->bodyHandler(new JSONBodyHandler($request))
        ->post()
        ->go();
  }

  /**
   * Updates the application with the given Id.
   *
   * @param string $applicationId The Id of the application to update.
   * @param array $request The request that contains all of the new application information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateApplication($applicationId, $request)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the application role with the given id for the application.
   *
   * @param string $applicationId The Id of the application that the role belongs to.
   * @param string $roleId The Id of the role to update.
   * @param array $request The request that contains all of the new role information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateApplicationRole($applicationId, $roleId, $request)
  {
    return $this->start()->uri("/api/application")
        ->urlSegment($applicationId)
        ->urlSegment("role")
        ->urlSegment($roleId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the consent with the given Id.
   *
   * @param string $consentId The Id of the consent to update.
   * @param array $request The request that contains all of the new consent information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateConsent($consentId, $request)
  {
    return $this->start()->uri("/api/consent")
        ->urlSegment($consentId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the email template with the given Id.
   *
   * @param string $emailTemplateId The Id of the email template to update.
   * @param array $request The request that contains all of the new email template information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateEmailTemplate($emailTemplateId, $request)
  {
    return $this->start()->uri("/api/email/template")
        ->urlSegment($emailTemplateId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the group with the given Id.
   *
   * @param string $groupId The Id of the group to update.
   * @param array $request The request that contains all of the new group information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateGroup($groupId, $request)
  {
    return $this->start()->uri("/api/group")
        ->urlSegment($groupId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the identity provider with the given Id.
   *
   * @param string $identityProviderId The Id of the identity provider to update.
   * @param array $request The request object that contains the updated identity provider.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateIdentityProvider($identityProviderId, $request)
  {
    return $this->start()->uri("/api/identity-provider")
        ->urlSegment($identityProviderId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the available integrations.
   *
   * @param array $request The request that contains all of the new integration information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateIntegrations($request)
  {
    return $this->start()->uri("/api/integration")
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the key with the given Id.
   *
   * @param string $keyId The Id of the key to update.
   * @param array $request The request that contains all of the new key information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateKey($keyId, $request)
  {
    return $this->start()->uri("/api/key")
        ->urlSegment($keyId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the lambda with the given Id.
   *
   * @param string $lambdaId The Id of the lambda to update.
   * @param array $request The request that contains all of the new lambda information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateLambda($lambdaId, $request)
  {
    return $this->start()->uri("/api/lambda")
        ->urlSegment($lambdaId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the registration for the user with the given id and the application defined in the request.
   *
   * @param string $userId The Id of the user whose registration is going to be updated.
   * @param array $request The request that contains all of the new registration information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateRegistration($userId, $request)
  {
    return $this->start()->uri("/api/user/registration")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the system configuration.
   *
   * @param array $request The request that contains all of the new system configuration information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateSystemConfiguration($request)
  {
    return $this->start()->uri("/api/system-configuration")
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the tenant with the given Id.
   *
   * @param string $tenantId The Id of the tenant to update.
   * @param array $request The request that contains all of the new tenant information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateTenant($tenantId, $request)
  {
    return $this->start()->uri("/api/tenant")
        ->urlSegment($tenantId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the theme with the given Id.
   *
   * @param string $themeId The Id of the theme to update.
   * @param array $request The request that contains all of the new theme information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateTheme($themeId, $request)
  {
    return $this->start()->uri("/api/theme")
        ->urlSegment($themeId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the user with the given Id.
   *
   * @param string $userId The Id of the user to update.
   * @param array $request The request that contains all of the new user information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateUser($userId, $request)
  {
    return $this->start()->uri("/api/user")
        ->urlSegment($userId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the user action with the given Id.
   *
   * @param string $userActionId The Id of the user action to update.
   * @param array $request The request that contains all of the new user action information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateUserAction($userActionId, $request)
  {
    return $this->start()->uri("/api/user-action")
        ->urlSegment($userActionId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the user action reason with the given Id.
   *
   * @param string $userActionReasonId The Id of the user action reason to update.
   * @param array $request The request that contains all of the new user action reason information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateUserActionReason($userActionReasonId, $request)
  {
    return $this->start()->uri("/api/user-action-reason")
        ->urlSegment($userActionReasonId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates a single User consent by Id.
   *
   * @param string $userConsentId The User Consent Id
   * @param array $request The request that contains the user consent information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateUserConsent($userConsentId, $request)
  {
    return $this->start()->uri("/api/user/consent")
        ->urlSegment($userConsentId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Updates the webhook with the given Id.
   *
   * @param string $webhookId The Id of the webhook to update.
   * @param array $request The request that contains all of the new webhook information.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function updateWebhook($webhookId, $request)
  {
    return $this->start()->uri("/api/webhook")
        ->urlSegment($webhookId)
        ->bodyHandler(new JSONBodyHandler($request))
        ->put()
        ->go();
  }

  /**
   * Validates the end-user provided user_code from the user-interaction of the Device Authorization Grant.
   * If you build your own activation form you should validate the user provided code prior to beginning the Authorization grant.
   *
   * @param string $user_code The end-user verification code.
   * @param string $client_id The client id.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function validateDevice($user_code, $client_id)
  {
    return $this->startAnonymous()->uri("/oauth2/device/validate")
        ->urlParameter("user_code", $user_code)
        ->urlParameter("client_id", $client_id)
        ->get()
        ->go();
  }

  /**
   * Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token is properly
   * signed and not expired.
   * <p>
   * This API may be used to verify the JWT as well as decode the encoded JWT into human readable identity claims.
   *
   * @param string $encodedJWT The encoded JWT (access token).
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function validateJWT($encodedJWT)
  {
    return $this->startAnonymous()->uri("/api/jwt/validate")
        ->authorization("JWT " . $encodedJWT)
        ->get()
        ->go();
  }

  /**
   * Confirms a email verification. The Id given is usually from an email sent to the user.
   *
   * @param string $verificationId The email verification id sent to the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function verifyEmail($verificationId)
  {
    return $this->startAnonymous()->uri("/api/user/verify-email")
        ->urlSegment($verificationId)
        ->post()
        ->go();
  }

  /**
   * Confirms an application registration. The Id given is usually from an email sent to the user.
   *
   * @param string $verificationId The registration verification Id sent to the user.
   *
   * @return ClientResponse The ClientResponse.
   * @throws \Exception
   */
  public function verifyRegistration($verificationId)
  {
    return $this->startAnonymous()->uri("/api/user/verify-registration")
        ->urlSegment($verificationId)
        ->post()
        ->go();
  }


  private function start()
  {
    return $this->startAnonymous()->authorization($this->apiKey);
  }

  private function startAnonymous()
  {
    $rest = new RESTClient();
    if (isset($this->tenantId)) {
      $rest->header("X-FusionAuth-TenantId", $this->tenantId);
    }
    return $rest->url($this->baseURL)
        ->connectTimeout($this->connectTimeout)
        ->readTimeout($this->readTimeout)
        ->successResponseHandler(new JSONResponseHandler())
        ->errorResponseHandler(new JSONResponseHandler());
  }
}